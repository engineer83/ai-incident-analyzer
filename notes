# Separate Dockerfiles for Frontend and Backend

Here's how to create separate Dockerfiles and reference them in Docker Compose:

## Project Structure

```
ing-incident-analyzer/
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile          # Backend-specific Dockerfile
‚îÇ   ‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.py         # FastAPI application
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ __init__.py
‚îÇ   ‚îî‚îÄ‚îÄ requirements.txt    # Backend dependencies
‚îÇ
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile          # Frontend-specific Dockerfile  
‚îÇ   ‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ frontend.py     # Streamlit application
‚îÇ   ‚îî‚îÄ‚îÄ requirements.txt    # Frontend dependencies
‚îÇ
‚îú‚îÄ‚îÄ docker-compose.yml      # Orchestrates both services
‚îî‚îÄ‚îÄ README.md
```

## 1. Backend Dockerfile

**backend/Dockerfile**:
```dockerfile
FROM python:3.9-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements and install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create non-root user for security
RUN useradd -m -u 1000 backend
USER backend

# Expose port
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

# Start FastAPI application
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--workers", "4"]
```

**backend/requirements.txt**:
```txt
fastapi==0.104.1
uvicorn==0.24.0
langchain==0.0.349
langchain-community==0.0.10
langchain-chroma==0.0.2
sentence-transformers==2.2.2
chromadb==0.4.15
ollama==0.1.2
requests==2.31.0
pydantic==2.5.0
python-multipart==0.0.6
```

## 2. Frontend Dockerfile

**frontend/Dockerfile**:
```dockerfile
FROM python:3.9-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements and install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create non-root user for security
RUN useradd -m -u 1000 frontend
USER frontend

# Expose port
EXPOSE 8501

# Health check
HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8501 || exit 1

# Start Streamlit application
CMD ["streamlit", "run", "app/frontend.py", \
     "--server.port=8501", \
     "--server.address=0.0.0.0", \
     "--server.enableCORS=false", \
     "--server.enableXsrfProtection=false"]
```

**frontend/requirements.txt**:
```txt
streamlit==1.28.1
requests==2.31.0
pandas==2.0.3
plotly==5.15.0
```

## 3. Docker Compose Configuration

**docker-compose.yml**:
```yaml
version: '3.8'

services:
  backend:
    build:
      context: ./backend  # Path to backend directory
      dockerfile: Dockerfile
    ports:
      - "8000:8000"  # Host:8000 ‚Üí Container:8000
    environment:
      - OLLAMA_HOST=ollama
      - ENVIRONMENT=production
      - CHROMA_DB_PATH=/app/chroma_db
    volumes:
      - chroma_data:/app/chroma_db
    networks:
      - ing-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  frontend:
    build:
      context: ./frontend  # Path to frontend directory
      dockerfile: Dockerfile
    ports:
      - "8501:8501"  # Host:8501 ‚Üí Container:8501
    environment:
      - API_BASE_URL=http://backend:8000  # Use service name for internal communication
      - STREAMLIT_SERVER_PORT=8501
      - STREAMLIT_SERVER_ADDRESS=0.0.0.0
      - STREAMLIT_BROWSER_GATHER_USAGE_STATS=false
    depends_on:
      backend:
        condition: service_healthy
    networks:
      - ing-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8501"]
      interval: 30s
      timeout: 10s
      retries: 5
    restart: unless-stopped

  ollama:
    image: ollama/ollama:latest
    ports:
      - "11434:11434"
    volumes:
      - ollama_data:/root/.ollama
    networks:
      - ing-network
    environment:
      - OLLAMA_HOST=0.0.0.0
    restart: unless-stopped

networks:
  ing-network:
    driver: bridge
    name: ing-incident-network

volumes:
  chroma_data:
    name: ing-chroma-data
  ollama_data:
    name: ing-ollama-data
```

## 4. Application Code Structure

**backend/app/main.py**:
```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI(title="ING Incident Analyzer API", version="1.0.0")

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/")
async def root():
    return {"message": "ING Incident Analyzer API", "version": "1.0.0"}

@app.get("/health")
async def health_check():
    return {"status": "healthy", "service": "backend"}

@app.get("/api/incidents")
async def get_incidents():
    # Your incident analysis logic here
    return {"incidents": []}
```

**frontend/app/frontend.py**:
```python
import streamlit as st
import requests
import os

# Get API URL from environment
API_BASE_URL = os.getenv("API_BASE_URL", "http://localhost:8000")

st.set_page_config(
    page_title="ING Incident Analyzer",
    page_icon="üîç",
    layout="wide",
    initial_sidebar_state="expanded"
)

def main():
    st.title("üîç ING Incident Analyzer")
    
    # Test API connection
    if st.button("Test Backend Connection"):
        try:
            response = requests.get(f"{API_BASE_URL}/health", timeout=5)
            if response.status_code == 200:
                st.success("‚úÖ Backend API is connected!")
            else:
                st.error(f"‚ùå API returned status {response.status_code}")
        except Exception as e:
            st.error(f"‚ùå Cannot connect to backend API: {e}")
            st.info(f"Trying to connect to: {API_BASE_URL}")
    
    # Your frontend application code here
    st.write("Welcome to the ING Incident Analysis Dashboard")

if __name__ == "__main__":
    main()
```

## 5. Build and Run Commands

**Build and start all services**:
```bash
# Build and start all services
docker-compose up -d --build

# Build specific service
docker-compose build backend
docker-compose build frontend

# Start specific service
docker-compose up -d backend
docker-compose up -d frontend
```

**Check service status**:
```bash
# View running containers
docker-compose ps

# View logs
docker-compose logs backend
docker-compose logs frontend

# Check health status
docker-compose exec backend curl http://localhost:8000/health
docker-compose exec frontend curl http://localhost:8501
```

## 6. Environment Configuration

**Create environment files**:

**.env** (common variables):
```env
ENVIRONMENT=development
APP_VERSION=1.0.0
```

**backend/.env**:
```env
OLLAMA_HOST=ollama
CHROMA_DB_PATH=/app/chroma_db
LOG_LEVEL=INFO
```

**frontend/.env**:
```env
API_BASE_URL=http://backend:8000
STREAMLIT_SERVER_PORT=8501
STREAMLIT_SERVER_ADDRESS=0.0.0.0
```

**Update docker-compose.yml to use env files**:
```yaml
services:
  backend:
    build: ./backend
    env_file:
      - .env
      - backend/.env
    # ...

  frontend:
    build: ./frontend  
    env_file:
      - .env
      - frontend/.env
    # ...
```

## 7. Docker Compose Overrides (Optional)

**docker-compose.override.yml** (for development):
```yaml
version: '3.8'

services:
  backend:
    volumes:
      - ./backend:/app  # Live reload for development
      - ./backend/chroma_db:/app/chroma_db
    environment:
      - ENVIRONMENT=development
      - RELOAD=true

  frontend:
    volumes:
      - ./frontend:/app  # Live reload for development
    environment:
      - ENVIRONMENT=development
```

**docker-compose.prod.yml** (for production):
```yaml
version: '3.8'

services:
  backend:
    environment:
      - ENVIRONMENT=production
      - RELOAD=false

  frontend:
    environment:
      - ENVIRONMENT=production
```

## 8. Useful Docker Commands

**Build and manage images individually**:
```bash
# Build backend image
docker build -t ing-backend:latest ./backend

# Build frontend image  
docker build -t ing-frontend:latest ./frontend

# Run individual containers
docker run -d -p 8000:8000 --name ing-backend ing-backend:latest
docker run -d -p 8501:8501 --name ing-frontend ing-frontend:latest

# Push to registry (if needed)
docker tag ing-backend:latest your-registry/ing-backend:latest
docker push your-registry/ing-backend:latest
```

## 9. Benefits of This Approach

### ‚úÖ **Separation of Concerns**
- Backend and frontend have different dependencies
- Different build processes
- Independent scaling

### ‚úÖ **Smaller Images**
- Each image contains only what it needs
- Faster builds and deployments
- Better security (smaller attack surface)

### ‚úÖ **Independent Development**
- Work on frontend without rebuilding backend
- Different teams can work independently
- Different update cycles

### ‚úÖ **Better Resource Management**
- Different resource limits for each service
- Independent scaling
- Separate monitoring and logging

## 10. Troubleshooting

**If you get build errors**:
```bash
# Check Dockerfile syntax
docker build -t test-backend ./backend

# Check compose file syntax
docker-compose config

# Debug build process
docker-compose build --no-cache --progress=plain backend
```

**Check container networking**:
```bash
# Test internal DNS resolution
docker-compose exec frontend ping backend

# Test API connectivity from frontend
docker-compose exec frontend curl http://backend:8000/health
```

This separated structure gives you a clean, maintainable setup where frontend and backend are completely independent but work together through Docker Compose orchestration!




docker-compose exec backend curl -H "Content-Type: application/json" request POST \
  --data 'Database down' \
  http://ollama:11434/api/analyze/root-cause